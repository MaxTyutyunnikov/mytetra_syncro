<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если вы пишете код на языке C или C++, поиск и устранение ошибок работы с памятью, таких, как утечки, выход за границы массива или обращение к неинициализированной памяти, могут доставить немало хлопот. Существует по крайней мере два инструмента для решения этих проблем — Valgrind (не путать с <a href="https://eax.me/vagrant/"><span style=" text-decoration: underline; color:#0000ff;">Vagrant</span></a>!) и Clang’овский <a href="http://clang.llvm.org/docs/MemorySanitizer.html"><span style=" text-decoration: underline; color:#0000ff;">MemorySanitizer</span></a>. Последний работает исключительно под Linux и показал себя несколько сырым и не слишком гибким инструментом, поэтому поговорим о Valgrind. Он довольно гибок и работает везде. Кроме того, в отличие от MemorySanitizer, Valgrind может находить неинициализированные данные с точностью до <span style=" font-style:italic;">одного бита</span>. Из недостатков Valgrind стоит отметить сравнительно низкую скорость работы. </p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Простой пример</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Перейдем сразу к делу и проверим работу Valgrind на такой программе:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />void run_test(int i)<br />{<br />  int delta = 123;<br />  char* mem = malloc(1024);<br />  strcpy(mem, &quot;i = &quot;);<br />  printf(&quot;%s %d\n&quot;, mem, i + delta);<br />  /* free(mem); */<br />}<br /><br />void main()<br />{<br />  int i;<br />  for(i = 0; i &lt; 10; i++)<br />    run_test(i);<br />}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Компилируем с отладочными символами и запускаем ее под Valgrind:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">gcc -O0 -g vgcheck.c -o vgcheck<br />valgrind ./vgcheck</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">Результат:</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">==1948== HEAP SUMMARY:<br />==1948==     in use at exit: 10,240 bytes in 10 blocks<br />==1948==   total heap usage: 11 allocs, 1 frees, 11,264 bytes allo...<br />==1948==<br />==1948== LEAK SUMMARY:<br />==1948==    definitely lost: 10,240 bytes in 10 blocks<br />==1948==    indirectly lost: 0 bytes in 0 blocks<br />==1948==      possibly lost: 0 bytes in 0 blocks<br />==1948==    still reachable: 0 bytes in 0 blocks<br />==1948==         suppressed: 0 bytes in 0 blocks<br />==1948== Rerun with --leak-check=full to see details of leaked memory</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Видим, что память утекла. Запускаем с <span style=" font-family:'monospace';">--leak-check=full</span>:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">==2047== 10,240 bytes in 10 blocks are definitely lost in loss recor...<br />==2047==    at 0x4C2AF1F: malloc (in /usr/lib/valgrind/vgpreload_mem...<br />==2047==    by 0x400561: run_test (vgcheck.c:8)<br />==2047==    by 0x4005AF: main (vgcheck.c:18)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теперь раскомментируем вызов <span style=" font-family:'monospace';">free</span> и уберем инициализацию переменной <span style=" font-family:'monospace';">delta</span>. Посмотрим, увидит ли Valgrind обращение к неинициализированной памяти:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">==2102== Conditional jump or move depends on uninitialised value(s)<br />==2102==    at 0x4E8003C: vfprintf (in /usr/lib/libc-2.25.so)<br />==2102==    by 0x4E87EA5: printf (in /usr/lib/libc-2.25.so)<br />==2102==    by 0x4005CA: run_test (vgcheck.c:10)<br />==2102==    by 0x4005F4: main (vgcheck.c:18)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Видит. Запустим с <span style=" font-family:'monospace';">--track-origins=yes</span> чтобы найти, откуда именно пришла неинициализированная переменаая:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">==2205== Conditional jump or move depends on uninitialised value(s)<br />==2205==    at 0x4E800EE: vfprintf (in /usr/lib/libc-2.25.so)<br />==2205==    by 0x4E87EA5: printf (in /usr/lib/libc-2.25.so)<br />==2205==    by 0x4005CA: run_test (vgcheck.c:10)<br />==2205==    by 0x4005F4: main (vgcheck.c:18)<br />==2205==  Uninitialised value was created by a stack allocation<br />==2205==    at 0x400586: run_test (vgcheck.c:6)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как видите, Valgrind нашел место объявления неинициализированной переменой с точностью до имени файла и номера строчки.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Теперь исправим все ошибки:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">==2239== HEAP SUMMARY:<br />==2239==     in use at exit: 0 bytes in 0 blocks<br />==2239==   total heap usage: 11 allocs, 11 frees, 11,264 bytes allo...<br />==2239== <br />==2239== All heap blocks were freed -- no leaks are possible</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Ну разве не красота?</p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Пример посложнее — запускаем PostgreSQL под Valgrind</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Рассмотрим, как происходит запуск под Valgrind больших программ, например, <a href="https://eax.me/postgresql-install/"><span style=" text-decoration: underline; color:#0000ff;">PostgreSQL</span></a>. Работа с памятью в этой РСУБД устроена особым образом. Например, в ней используются иерархические пулы памяти (memory contexts). Для понимания всего этого хозяйства Valgrind’у нужны подсказки. Чтобы такие подсказки появились, нужно раскомментировать строчку:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">#define USE_VALGRIND</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">… в файле src/include/pg_config_manual.h, после чего полностью <a href="https://eax.me/postgresql-build/"><span style=" text-decoration: underline; color:#0000ff;">пересобрать PostgreSQL</span></a>. Затем запуск под Valgrind осуществляется как-то так:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">valgrind --leak-check=no --track-origins=yes --gen-suppressions=all \<br />  --read-var-info=yes \<br />  --log-file=$HOME/work/postgrespro/postgresql-valgrind/%p.log \<br />  --suppressions=src/tools/valgrind.supp --time-stamp=yes \<br />  --trace-children=yes postgres -D \<br />  $HOME/work/postgrespro/postgresql-install/data-master \<br />  2&gt;&amp;1 | tee $HOME/work/postgrespro/postgresql-valgrind/postmaster.log</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Полный пример вы найдете в <a href="https://github.com/afiskon/pgscripts/blob/master/valgrind.sh"><span style=" text-decoration: underline; color:#0000ff;">файле valgrind.sh</span></a> из <a href="https://github.com/afiskon/pgscripts"><span style=" text-decoration: underline; color:#0000ff;">этого репозитория</span></a> на GitHub.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Обратите внимание на флаг <span style=" font-family:'monospace';">--leak-check=no</span>. Даже с упомянутыми подсказками Valgrind все равно не подходит для поиска утечек памяти в PostgreSQL. Он попросту будет генерировать слишком много ложных сообщений об ошибках. Поэтому здесь Valgrind используется только для поиска обращений к неинициализированной памяти.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Флаг <span style=" font-family:'monospace';">--trace-children=yes</span> в приведенной выше команде, как несложно догадаться, говорит Valgrind’у цепляться к процессам-потомкам.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Еще стоит отметить флаг <span style=" font-family:'monospace';">--suppressions</span>, который задает <a href="https://github.com/postgres/postgres/blob/master/src/tools/valgrind.supp"><span style=" text-decoration: underline; color:#0000ff;">файл с описанием ошибок</span></a>, которые следует игнорировать, а также флаг <span style=" font-family:'monospace';">--gen-suppressions=all</span>, который в случае возникновения ошибок генерирует строки, которые можно добавить в этот самый файл для игнорирования ошибок. Кстати, в файле можно <a href="https://wiki.wxwidgets.org/Valgrind_Suppression_File_Howto#Wildcards"><span style=" text-decoration: underline; color:#0000ff;">использовать wildcards</span></a>, в стиле:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">{<br />   &lt;libpango&gt;<br />   Memcheck:Leak<br />   ...<br />   obj:/usr/*lib*/libpango*<br />}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В зависимости от используемых флагов, <span style=" font-family:'monospace';">make installcheck</span> под Valgrind’ом на <a href="https://eax.me/fujitsu-lifebook-e733/"><span style=" text-decoration: underline; color:#0000ff;">моем ноутбуке</span></a> выполняется от получаса до часа. Для сравнения, без Valgrind’а соответствующий прогон тестов занимает порядка 3.5 минут. Отсюда можно сделать вывод, что программа под Valgrind выполняется в 10-20 раз медленнее.</p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Использование Valgrind совместно с GDB</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Посмотрев на приведенные выше отчеты Valgrind’а об ошибках, можно заметить, что в определенном смысле они недостаточно информативны. В частности, в них нет имен переменных и информации о том, какие конкретно данные в них лежали на момент возникновения ошибки. Решается эта проблема запуском Valgrind’а с флагами:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">valgrind --vgdb=yes --vgdb-error=1 дальше_как_обычно</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Эти флаги говорят Valgrind остановить процесс и запустить gdb-сервер после возникновения первой ошибки. Можно указать и <span style=" font-family:'monospace';">--vgdb-error=0</span>, чтобы подключиться к процессу отладчиком сразу после его запуска. Однако это может быть плохой идеей, если вы также указали <span style=" font-family:'monospace';">--trace-children=yes</span> и при этом программа создает множество дочерних процессов.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">При возникновении ошибки Valgrind напишет:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">==00:00:00:06.603 16153== TO DEBUG THIS PROCESS USING GDB: start GDB...<br />==00:00:00:06.603 16153==   /path/to/gdb postgres<br />==00:00:00:06.603 16153== and then give GDB the following command<br />==00:00:00:06.603 16153==   target remote | vgdb --pid=16153</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">После этого, чтобы подключиться к процессу при помощи <a href="https://eax.me/gdb/"><span style=" text-decoration: underline; color:#0000ff;">GDB</span></a>, говорим:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;"># где postgres - имя исполняемого файла<br />gdb postgres</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">… и уже в отладчике:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">target remote | vgdb --pid=16153</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Из интересных дополнительных команд доступны следующие. Посмотреть список утечек:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">monitor leak_check</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Узнать, кто ссылается на память:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">monitor who_points_at (address) (len)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Проверка инициализированности памяти (0 — бит инициализирован, 1 — не инициализирован, _ — not addressable):</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">monitor get_vbits (address) (len)</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Прочее:</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'FreeMono'; color:#6a1009;">monitor help</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Дальше отлаживаем, как обычно. Например, говорим <span style=" font-family:'monospace';">continue</span>. Как только произойдет следующая ошибка, программа снова остановится по брейкпоинту. Можно смотреть значения переменных, перемещаться между фреймами стека, ставить собственные брейкпоинты, и так далее.</p>
<p style=" margin-top:14px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:large; font-weight:600;">Заключение</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">К сожалению, в рамках одного поста невозможно рассмотреть абсолютно все возможности Valgrind. Например, в него входят инструменты <a href="http://valgrind.org/docs/manual/cl-manual.html"><span style=" text-decoration: underline; color:#0000ff;">Callgrind</span></a> и <a href="http://valgrind.org/docs/manual/ms-manual.html"><span style=" text-decoration: underline; color:#0000ff;">Massif</span></a>, предназначенные для поиска узких мест в коде и профилирования памяти соответственно. Эти инструменты я не рассматриваю, так как для решения названных задач предпочитаю <a href="https://eax.me/c-cpp-profiling/"><span style=" text-decoration: underline; color:#0000ff;">использовать perf</span></a> и <a href="https://eax.me/heaptrack/"><span style=" text-decoration: underline; color:#0000ff;">Heaptrack</span></a>. Также существует инструмент <a href="http://valgrind.org/docs/manual/hg-manual.html"><span style=" text-decoration: underline; color:#0000ff;">Helgrind</span></a>, предназначенный для поиска гонок. Его изучение я вынужден оставить вам в качестве упражнения.</p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Как видите, пользоваться Valgrind крайне просто. Он, конечно, не идеален. Как уже отмечалось, Valgrind существенно замедляет выполнение программы. Кроме того, в нем случаются ложноположительные срабатывания. Однако последняя проблема решается составлением специфичного для вашего проекта файла подавления конкретных отчетов об ошибках. Так или иначе, если вы пишете на C/C++ и не прогоняете код под Valgrind хотя бы в <a href="https://eax.me/jenkins/"><span style=" text-decoration: underline; color:#0000ff;">Jenkins</span></a> или TeamCity незадолго до релиза, вы явно делаете что-то не так!</p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p></body></html>